<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>3- Başlarken</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="3db0c3cc-8851-441e-8c1d-fd3bec480789" class="page sans"><header><h1 class="page-title">3- Başlarken</h1></header><div class="page-body"><h2 id="c7fca933-7c44-4d9b-a46a-2c695e6adb84" class="">Başlarken</h2><p id="cae63784-8ece-4b99-ad4f-23b8f90afb35" class="">Gerekli çalışma ortamını kurduk ve artık çalışmak için hazırız. Anlatımlara başlamadan önce belirtmem gerekiyor ki, biz bu eğitimde Linux sisteminin temel kullanımından yani sistem yönetiminin temellerinden bahsetmeyeceğiz. Bizim bu eğitimdeki amacımız; halihazırda yönetebildiğimiz sistemdeki işlerimizi kolaylaştırmak veya verimini artırmak için bash kabuğunu daha yakından tanıyıp işlerimizi nasıl senaryolaştırabileceğimizi(scripting) öğrenmektir.</p><p id="c7f74c81-8f79-4e4f-b3ed-f60cc0515ffe" class="">Bu durumun nedeni konu kapsamını mümkün oldukça dağıtmadan verimli şekilde öğrenmenizi sağlamaktır. Ancak ben yine de konu bütünlüğünü sağlamak adına sistem yönetimi ve kullanılan harici komutlar hakkında yeri geldikçe kısa hatırlatmalarda bulunuyor olacağım.</p><p id="2458ac5a-ddc2-4ffb-bd16-edac351583d5" class="">Kısacası bu eğitimden verim alabilmeniz için en azından temel seviye Linux bilgisine sahip olmanızı şiddetle tavsiye ederim. Şayet bu konuda eksiğiniz varsa, benim bir önceki video eğitimim olan &quot;Kali Linux ile Sıfırdan Temel Linux Eğitimi&quot; kursuna kaydolmanızı ya da &quot;Temel Linux Eğitimi&quot; dokümantasyonuna göz atamanızı öneririm. Zira bu eğitim temel Linux eğitimimin devamı niteliğinde, eğitimden maksimum verim alabilmek adını her iki eğitimi de bir bütün olarak ele almanız çok daha iyi olacaktır.</p><p id="b4d679ff-4e7f-4b59-9307-e8928d2464fe" class="">Bu girizgahtan sonra artık esas konumuza dönebiliriz.</p><p id="73f29df5-50f6-4b12-a12a-b19800b224cd" class="">Öncelikle yönetmekte olduğumuz kullanıcı hesabında hangi kabuk programı kullanılıyor bu öğrenelim. Öğrenmek üzere konsola <code>echo $SHELL</code> komutunu girebiliriz.</p><figure id="b6fbc98d-5cb2-43a4-ad53-d1f828b1f1b4" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/1.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/1.png"/></a></figure><p id="a3f4be96-35f9-4e46-988d-1d1ae1978c5c" class="">Burada &quot;<strong>SHELL</strong>&quot; olarak geçen ifade mevcut kullanıcı hesabı için varsayılan kabuğun hangisi olduğunun bilgisine tutan <strong>değişkendir</strong>. <code>echo</code> komutu da bu değişkenin değerini konsola bastırmamızı sağlayan araçtır. Çıktıda yer alan &quot;<strong>/bin/bash</strong>&quot; ifadesi, bash kabuğunun tam dosya konumunu belirtiyor. Bu sayede mevcut kullanıcı için varsayılan kabuğun &quot;bash&quot; olduğunu öğrenmiş olduk.</p><p id="68e50e8a-c99a-4a87-ab33-18bbe0ef743e" class="">Eğer sizin kullanıcı hesabınızdaki varsayılan kabuk &quot;bash&quot; değilse kolay çalışabilmek adına devam etmeden önce &quot;bash&quot; olarak değiştirmeniz gerekiyor. Aslında varsayılan kabuğu bash olarak değiştirmeden konsola <code>bash</code> komutunu girdiğimizde de bash kabuk ortamında çalışmaya başlarız. </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="934b3846-157f-411c-a7e2-36e487d0c85f"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%"><mark class="highlight-yellow">Not:</mark> Eğer kullanmakta olduğunuz sistemde bash kabuğu yüklü değilse <code>bash</code> komutunun neticesinde &quot;komut yok&quot; şeklinde hata almış olabilirsiniz. Bu durumda tek yapmanız gereken bash kabuğunu mevcut sisteminize yüklemektir. Bash kabuğunu nasıl yükleyeceğimizi &quot;Gerekli Ortamın Kurulması&quot; bölümünde detaylıca ele aldık. Ayrıca mevcut sistemi temel düzeyde kullanabiliyor olmanızın eğitimi takip edebilmek için şart olduğunu başta belirtmiştik hatırlarsanız. Çünkü tanımadığınız sistemi yönetmek için programlayamazsınız. Bizler sistemi yönetmeyi değil bash programlamanın esaslarını öğreniyor olacağız.</div></figure><p id="b63795bd-6f37-4ffa-be5c-fa692a5922d0" class=""><code>bash</code> komutu ile başlatabilecek olsa da biz her seferinde bu işlem ile uğraşmak istemediğimiz için bash kabuğunu mevcut hesabımız için varsayılan olarak ayarlayabileceğimize de değinelim.</p><h2 id="02401e65-1245-4824-b822-bd217f4208f1" class="">Varsayılan Kabuğu BASH Olarak Değiştirmek</h2><p id="6433eda3-530e-4071-a025-df481c75dfb3" class="">Değiştirmek için öncelikle &quot;bash&quot; kabuğunun sistem üzerinde hangi konumda yüklü olduğunu öğrenmemiz gerekiyor. Öğrenmek üzere <code>which bash</code> komutunu kullanabiliriz. </p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="64f51b17-72b5-4dab-9d49-46d2666d0e16" class="code"><code>$ which bash
<span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>bash</code></pre><p id="926ed70d-c4ed-4aeb-a8b7-7bdc1627d9a9" class="">Aldığımız çıktı bash kabuğunun tam dosya konumunu belirtiyor. Sizde bu çıktı benimkinden farklı olabilir. Zaten farklı olma ihtimaline karşı <code>which</code> komutu ile bash kabuğunun dosya konumunu saptamaya çalıştık. </p><p id="809aa712-2a13-4aab-afc1-ebc5e1016242" class="">Artık bash kabuğunun tam dosya konumunu öğrendiğimize göre, mevcut kullanıcı hesabımız için bash kabuğunu varsayılan yapabiliriz. Bu sayede hesabımızda her oturum açtığımızda konsol üzerinden doğrudan bash kabuğuna emir verebiliyor olacağız.</p><p id="11591caa-641c-4953-9335-b9570ea27e1b" class="">Kullanıcıların varsayılan kabuk ayarını değiştirmek için, kullanıcıların temel hesap bilgilerinin tutulduğu <strong><em>/etc/passwd </em></strong>dosyasında değişiklik yapmamız gerekiyor. Bu dosyayı yetkili olarak herhangi bir metin editörü ile açalım.</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="5a2d8179-3c8b-49fe-8890-74f4601ba048" class="code"><code><span class="token function">sudo</span> <span class="token function">nano</span> /etc/passwd</code></pre><p id="e195d243-b811-474e-af00-9a95677808d2" class="">Dosyayı açtıktan sonra, kabuğunu değiştirmek istediğimiz kullanıcı satırını bulup, sondaki kabuk adresini bash kabuğunun tam dosya adresi ile değiştirelim. Örneğin ben zsh olan kabuğu bash ile değiştirmeyi örnekledim.</p><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="77ad37a0-51d9-4788-8f8d-968a420f5f27" class="code"><code>taylan:x:1000:1000:,,,:/home/taylan:/usr/bin/zsh</code></pre><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism.min.css')</style><pre id="9c12aa91-0cb1-4b8d-b0a4-8ee8e37964d1" class="code"><code>taylan:x:1000:1000:,,,:/home/taylan:/bin/bash</code></pre><p id="29b565d3-eba8-47e2-ae0c-5a91d2442795" class="">Dosyadaki değişikliği kaydettikten sonra oturumunuzu kapatıp tekrar açtığınızda ilgili değişiklik geçerli olacaktır. Değişikliği <code>echo $SHELL</code> komutu ile teyit edebilirsiniz.</p><p id="5e139a4e-a36b-428e-b3d0-4fecace682db" class="block-color-red">
</p><p id="30cdfa49-b655-4860-8d67-4aa290b1bd6f" class="block-color-red">Öğrenmek üzere <em><strong>/etc</strong></em> dizini altında yer alan <em><strong>shells</strong></em> isimli dosyanın içeriğine bakabiliriz. Bu dosya aynı zamanda daha önce de bahsettiğimiz şekilde sistem üzerinde birden fazla kabuk programının yüklü olduğunu teyit edebilmemizi de sağlıyor.</p><p id="16e216d5-f20a-4019-893d-858212bca1cb" class="block-color-red">Konsola <code>cat /etc/shells</code> komutunu girerek dosyamızın içeriğini okuyalım.</p><figure id="67fa6499-a392-408c-94f4-95a0a78201b7" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/3.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/3.png"/></a></figure><p id="14253301-0320-415a-8359-0dd11cd6269f" class="block-color-red">Gördüğünüz gibi sistemde yüklü bulunan kabuk programlarının hepsi bu dosya içerisinde listelenmiş bulunuyor. Birden fazla kabuk olma durumunu teyit ederken, sizde yer alan kabuk program çeşitleri bende listelenmiş olanlardan eksik ya da fazla gözüküyor olabilir. Bu durumun nedeni sistemde yer alan kabuk program çeşitlerinin, kullanılan dağıtıma göre değişiklik gösterebiliyor olmasıdır. Yani benimle bire bir aynı çıktıları almadıysanız da hiçbir problem yok. Çünkü zaten bizim bu eğitimde odaklanacağımız kabuk programı &quot;bash&quot; kabuğudur. </p><p id="ea834780-e75b-486a-b6a6-aa7d04e2cfab" class="block-color-red">Yine de buna rağmen bash kabuğu için bile birden fazla konum göze çarpıyor. Tek bir kabuk için neden birden fazla dosya konumu listelendi ki ?</p><p id="fb9b2f0b-132b-4f48-9cfa-f940a7f02148" class="block-color-red">Bu durumun nedeni dosya sistemi hiyerarşisi ile ilgili aslında. Yani temel linux eğitimine göz atmanız daha doğru bilgi almanızı sağlar. BU BİLGİYİ EKLEE</p><p id="c72cfd51-434a-4960-8cb8-3ce0c357d94c" class="block-color-red">örneğin redhat üzerinde $SHELL ve $BASH çıktıları /bin/bash ve /usr/bin/bash şeklinde oluyor. Bunun nedenini iyi biçimde araştır ve söyle. Eskiden kullanılan disk yapısı ve gerektiğinde sistemi kutarmak için tek kullanıcılı mod ya da boot aşamasında gerekli minimum özelliklerin /bin içinde yer aldığı falan söyleniyor araştır.</p><p id="8deebdf0-87b7-4ec6-b477-f790f2785685" class="">
</p><p id="b91bcf36-75f9-406d-96b1-d07da482856a" class="">En nihayetinde; daha önce de belirttiğimiz şekilde birden fazla kabuk programının olduğunu ve bunların aynı sistemde yüklü bulunabileceğini ve hatta dilediğimiz kabuğu kullanabileceğimizi de hep birlikte teyit etmiş olduk.</p><p id="850c7051-12bb-4492-84ae-be33ee24399f" class="">
</p><p id="6d943f15-4649-4743-b7f0-9ede2e7d790a" class="">
</p><h2 id="ceb54749-ea37-4f4d-acfe-534903923519" class="">Script Dosyası(Betik) Oluşturma</h2><p id="a5f639ac-c36f-4c58-8bdb-c191c98983c2" class="">Bash script yazarken ilk olarak dosyanın başına unix sistemlerinde &quot;<strong>shebang&quot; </strong>olarak geçen &quot;<strong>#!</strong>&quot; tanımını, betiğin çalıştırılacağı ortamı da belirterek &quot;<strong>#!/bin/bash</strong>&quot; şeklinde eklememiz gerekiyor.</p><figure id="18ebe8fd-d7e9-42c5-be43-5a5408e9095e" class="image"><a href="3-%20Bas%CC%A7larken%2018ebe8fdd7e942c5be435a5408e9095e/shebang.png"><img style="width:2036px" src="3-%20Bas%CC%A7larken%2018ebe8fdd7e942c5be435a5408e9095e/shebang.png"/></a></figure><p id="e503e7e1-278a-418a-aa8b-cbc1c94fdaff" class="">İlk satıra eklenen bu ifade, sonraki alt satırların hangi çalışma ortamı tarafından yorumlanacağını bildiren standart bir tanımdır. Dosya açıldığında ilk olarak buraya bakılır ve dosyanın çalıştırılabilir ortamının mevcut olup olmadığına karar verilir. İlgili ortam sistemde yüklü ise dosya bu ortam üzerinden çalıştırılır. Dolayısıyla komutların doğru yorumlanabilmesi için her bash script dosyasında bu tanım mutlaka bulunmalıdır.</p><p id="be9cd7bb-f82f-47ae-a385-6d25041a0198" class="">Ayrıca bu kullanımın dışında çalıştırılacak ortamı <code>#!/usr/bin/env bash</code> şeklinde belirtmeniz de mümkün. Bu kullanım ile bash ortamının sistemde kurulu olduğu konum otomatik olarak bulunup betik dosyası bu ortam üzerinden çalıştırılıyor. Bu neden gerekli diyecek olursanız; istisnai durumlarda bash ortamı bizim ilk olarak belirtiğimiz konum olan <strong>/bin/bash</strong> konumunda yer almayabiliyor. Nitekim <strong><em>/etc/shells</em></strong> dosyasında da bu durumu bizzat görmüştük. Bu gibi durumlarda betik dosyamızın çalıştırılacağı bash ortamının sistem üzerinde nerede kurulu olduğunu tayin etme işini <code>env</code> aracı üstleniyor. <code>env</code> aracı, çevre değişkenlerini sorgulayarak bash ortamının sistem üzerinde yüklü olduğu konumu kolayca bulabiliyor.</p><p id="c6b22b15-d545-426f-b9cc-428c8460c6ce" class="">Peki ama <code>env</code> komutu tüm sistemlerde <em><strong>/usr/bin/</strong></em><em> </em>altında mı ? Yani <code>env</code> komutunun konumu da sistemden sisteme göre değişmiyor mu ? Çok nadir durumlar dışında hayır değişmiyor, çünkü pek çok betik dosyası bu yöntem ile çalıştırılacak ortamı belirtiyor. Sistemler de bu durumu göz önünde bulundurarak env aracının dosyasını <em><strong>/usr/bin/</strong></em><strong> </strong>dizinini altında tutuyor.<strong> </strong>Bu durumu gözlemlemek adına, farklı sistemler üzerinden bu durumu teyit etmeyi deneyebilirsiniz. Debian, Ubuntu, CentOS, MacOS, SUSE, RHEL, NetBSD, OpenBSD, FreeBSD, Solaris.. sistemlerinde <em><strong>/usr/bin/env </strong></em>konumunda yer alıyor.</p><p id="f62173c1-ff9b-4bbd-ab3a-fbcd12de50a2" class="">Kafanızda soru işareti kalmaması adına biraz daha açıklamak istiyorum. Bahsi geçen <code>env</code> komutu İngilizce &quot;<strong>environments</strong>&quot; ifadesinin yani &quot;<strong>ortam</strong>&quot; ifadesinin kısaltmasıdır. Görevi de sistem üzerinde yüklü bulunan ortamlardan haberdar olup, gerektiğinde bu ortamların çalıştırılabilmesini sağlamaktır. Örneğin Python ile yazılmış bir programın çalışması için Python ortamına ihtiyacı vardır. Çünkü Python dili ile yazılmış ifadeleri yalnızca Python ortamı anlamlandırıp, bilgisayarımıza aktarabilir. Eğer sistemimizde Python ortamı yüklü ise bizler bu ortamın nerede bulunduğunu bilmeye ihtiyaç duymadan <code>env python</code> komutu ile gerekli ortamın açılmasını sağlayabiliriz. Çünkü Python çalışma ortamı farklı sistemlerde farklı konumlarda bulunuyor olabilir ve ayrıca dosyanın Python ortamı ile çalışması gerektiğini de <code>env</code> sayesinde özellikle bildirmiş oluyoruz. İşte bizler de yazmış olduğumuz aracın tüm sistemlerde kendi çalışma ortamını otomatik olarak bulunup çalıştırılabilmesi için <code>env</code> komutundan faydalanıyoruz. Bu sayede eğer sistem üzerinde bash ortamı yüklü ise <code>env</code> komutu gidip bash ortamını bulup çalıştırıyor. Yani bu kullanım, yazmış olduğumuz betik dosyalarının tüm Linux sistemlerinde ortak olarak çalıştırılabilmesi için diğer bir deyişle betik dosyamızın taşınabilir bir dosya olması için elzemdir. Dolayısıyla komutların doğru yorumlanabilmesi için her bash script dosyasında mutlaka bulunmalıdır.</p><figure id="8749f324-a2a4-4f89-84ca-aae7dab33dd3" class="image"><a href="3-%20Bas%CC%A7larken%2018ebe8fdd7e942c5be435a5408e9095e/shebang-env-lt.png"><img style="width:2580px" src="3-%20Bas%CC%A7larken%2018ebe8fdd7e942c5be435a5408e9095e/shebang-env-lt.png"/></a></figure><p id="aad6d4c8-7537-4087-b281-100e16f5ec61" class="">Program çalıştırıldığında sistem tarafından öncelikle ilk satır okunur ve ilk satırda geçen kabuk diline göre program ilgili kabuk dili aracılığı ile çalıştırılır.</p><p id="3d0158db-9d18-4846-b761-2e95c74cbc4b" class="">Şayet ilk satıra hiç bir ifade eklemezseniz, sistem varsayılan olarak mevcut kabuk üzerinden script dosyasını çalıştırmayı dener. Yani aslında mevcut sisteminizde kullanılan kabuk bash ise, &quot;<strong>#!/usr/bin/env bash</strong>&quot; ifadesini betik dosyanıza eklemeseniz dahi betik dosyanız, sistemde varsayılan kabuk bash olduğundan sorunsuz şekilde çalışacaktır. Ancak yine de yazmış olduğunuz betik dosyasının, diğer sistemlerde de doğru şekilde çalıştırılabilmesi için &quot;<strong>#! /usr/bin/env bash</strong>&quot; yani &quot;shebang&quot; ifadesini betik dosyanızın başına eklemiş olmanız son derece önemlidir. Zira çoğu Linux dağıtımı bash kabuğunu varsayılan olarak kullanıyor olsa da, istisnai durumlarda farklı kabukların varsayılan olarak kullanıldığı da olabiliyor. Örneğin sizin bash için yazdığınız betik dosyası, varsayılan çalışma ortamı zsh olan bir sistemde çalıştırıldığında eğer başında bu betik dosyasının bash ortamında çalışmaya uygun olduğunu belirten shebang ifadesi yoksa doğru şekilde çalışmayacaktır. Çünkü sistem dosyayı açtığında özellikle bir çalışma ortamı belirtilmediğini görecek ve varsayılan kabuk(örneğimizdeki kabuk zsh) üzerinden çalıştırmayı deneyecektir.</p><p id="11b5f90f-23bf-4ec4-986d-3ae593effa38" class="">Ayrıca shebang ifadesinin satır başına eklenmesi, biraz da &quot;clean code&quot; denilen &quot;düzenli(temiz) kod&quot; yazma kültürünün bir parçasıdır. Bu gibi alışkanlıklar uzun vadede verimli çalışmalar ortaya koymak adına oldukça önemli. Siz veya betik dosyanızı paylaştığınız diğer insanlar dosyayı açıp baktıklarında bash kabuğu için yazılmış olduğunu bu sayede kolayca fark edebilir. İlerleyen zamanlarda kendi yazmış olduğunuz betikleri açıp incelediğinizde ya da diğer insanların yazmış olduğu kapsamlı betik içeriklerini incelerken bu gibi düzenli çalışmaların, programın çalışma yapısını anlamada ne kadar kolaylık sağladığını sizler de görmüş olacaksınız.</p><p id="412c28e6-053e-4c41-984a-7ae4f59d56c1" class="">Evet, script içerisinde kullanılan kabuk program çeşidini diğer bir deyişle gerekli çalışma ortamını dosyamızın en başına yazdığımıza göre artık script yazmaya tamamen hazırız.</p><p id="bfeb69c2-bc33-42ec-bfef-0b48aa310d00" class="">İlk scriptimize, konsol ekranına çıktı basan standart bir örnek ile başlayalım istiyorum. Aksi halde başımıza taş falan yağabilir :)</p><p id="98b6365a-a159-4c67-be00-0cae97310e42" class="">Bunun için konsola çıktı basan komutumuz olan <code>echo</code> komutunu kullanacağız. Örneğin ben konsola <code>echo &quot;selamlar&quot;</code> yazarsam, çıktı olarak <strong>selamlar</strong> ifadesi konsola basılmış olacak.</p><figure id="91932fed-75c1-403d-9447-6e67dc481baf" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/5.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/5.png"/></a></figure><p id="41770a82-d9b1-4091-9648-529a79798e1b" class="">İşte bu komutu betik dosyamızın içerisine yazıp kaydedersek, betik dosyamızı her çalıştırdığımızda konsol ekranına <strong>selamlar</strong> ifadesi otomatik olarak basılacaktır.</p><p id="6aae59bb-2d62-4680-8274-fb1959434037" class="">Hemen test etmek için <code>echo &quot;selamlar&quot;</code> komutumu betik dosyamın içerisine yazıp, dosyamı &quot;<a href="http://selam.sh/"><strong>selam.sh</strong></a>&quot; ismi ile kaydediyorum.</p><figure id="75fe7f76-e17c-4e81-a741-ef7d7a739685" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/6.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/6.png"/></a></figure><p id="66726987-db05-4848-9f2f-568b6d8a3935" class="">Dosyamı kaydederken dosya isminin sonuna <strong>.sh</strong> dosya uzantısını eklemem mecburi olmasa da, biraz önce bahsettiğimiz düzenli çalışma adına önemli bir ayrıntı olduğu için ekledim.
Aslında betik dosyamız, uygun çalışma ortamına sahip olduğu sürece sonunda &quot;<strong>sh&quot;</strong> uzantısı olmadan da çalışabilir. Ancak ileride hangi dosyaların betik dosyası olduğunu anlama konusunda, dosyaların sonlarındaki &quot;<strong>sh&quot;</strong> ifadeleri bizlere yardımcı olacağı için özellikle belirtilmesi önemlidir. Zira Linux sistemlerinde dosyayı çalıştırırken dosyanın uzantısının bir önemi yoktur. İlgili dosyanın çalıştırılması için gereken ortam sistemde yüklü ise dosya çalıştırılır. Yine de bu gibi uzantıları eklemek, dosyanın daha sonra kolay bulunabilmesi adına sınıflandırmaya katkı sunar.</p><p id="76d9023b-af0d-4e68-b561-36ae86b83e6e" class="">Bu durumu daha iyi anlamak adına, yüzlerce dosyanın bulunduğu bir klasör ve bu klasördeki dosyaların hiç birinde ayırt edici uzantı bulunmadığı bir durum hayal edin. Böyle bir durumda hangi dosyanın betik dosyası olduğunu anlamanın tek yolu, dosyaların her birini tek tek açarak içlerine bakmayı gerektirir. Tahmin edebileceğiniz gibi bu işlemde inanılmaz vakit alacaktır. Bu gibi vakit kayıplarını önlemenin en ideal yolu dosya isimlerinin sonunda dosya türlerini belirterek, dosyaları sınıflandırabilir kılmaktır.</p><p id="94565f8d-951a-4191-958a-a786447f56b8" class="">Daha somut bir örnek görmek adına örneğin; içerisinde bir çok dosyanın bulunduğu bir dizindeyken, konsola
<code>ls *.sh</code> gibi kısacık bir komut girerek sonunda <strong>.sh</strong> ifadesi geçen tüm betik dosyalarını tek seferde listeleyebiliriz.</p><figure id="23d325e2-264a-458e-ae34-97b04f40dc29" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/7.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/7.png"/></a></figure><figure id="d2f7063a-f3cb-4c37-947c-b2def686c286" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/8.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/8.png"/></a></figure><p id="dbcd2ad2-f012-425d-9f56-a2046839e46f" class="">Ayrıca dosyalara uzantı eklemek, dosyayı çalıştırabilecek olan programların dosyaları kolay algılayabilmesini de sağlar. Örneğin kullanmakta olduğunuz editör destekliyorsa, bash programlamaya özel renklendirme ve programlamayı kolaylaştıran bir takım araçlar &quot;<strong>sh&quot;</strong> uzantısı sayesinde kullanılabilir olur.</p><p id="a9401b8f-2a3a-4b91-b100-071503946459" class="">Basit bir örnek olması açısından sonu &quot;<strong>sh&quot;</strong> ile biten ve bitmeyen iki dosyayı editör üzerinde açarak karşılaştırma yapabilirsiniz. Bu duruma ek olarak dosya uzantıları, özellikle grafiksel arayüz kullanımında, dosyanın üzerine tıklandığında çalıştırılabilir olan araç ile doğrudan açılması gibi kolaylıklar da sağlar.</p><p id="29fd598e-f5d6-40f7-8c47-bcc25ee863a5" class="">Yani kısacası dosyamı, sonunda &quot;<strong>.sh&quot;</strong> uzantısı olmadan da kaydetsem çalışacaktır. Ancak bu ifadeyi ekleyerek kazanacağım olumlu özellikler düşünüldüğünde, eklemeden kaydetmek oldukça mantıksız olacaktır.</p><p id="d55a753a-8464-4733-9967-359b19dc0921" class="">Ayrıca dosya isimlerinizde mümkün oldukça <strong>Türkçe karakter</strong> ve <strong>kelimeler arasında boşluk</strong> kullanımından kaçınmanızı öneririm. Zira kimi sistemlerde Türkçe karakter ve boşluk karakterinden doğacak sorunlar yüzünden betik dosyanız çalıştırılamayabilir.</p><p id="bd3cbfde-8c97-459f-9e20-415349d6756a" class="">Aşağıdaki kullanımlar global isimlendirmeye <strong>uygun olmayanlara</strong> birkaç örnektir.</p><p id="cbfd243e-fb69-42a2-ab77-da823017d2ba" class=""><strong>Örn;</strong> &quot;<strong>betik dosyası</strong>&quot;, &quot;<strong>merhaba dünya</strong>&quot;, &quot;<strong>test betiği</strong>&quot;, &quot;<strong>fıstıkçı şahap</strong>&quot;, &quot;<strong>BETİK</strong>&quot;.. vb..</p><p id="f6afb58e-3180-4880-a1a3-59c0c6e33aee" class="">Yukarıdaki örneklerde hem Türkçe karakter hem de kelimeler arası boşluk var ve bu tür isimlendirmeler, global yani herkes tarafından kullanılabilir betik dosyaları için yanlış isim tercihlerdir.</p><h2 id="ed410e41-57a0-44bf-94a6-64d7ed357ad0" class="">Betik Dosyalarını Çalıştırmak</h2><p id="30fc699f-3640-4fb6-b45d-9811f9fbd588" class="">Yazmış olduğumuz betik dosyasını çalıştırmanın birden fazla yolu bulunmaktadır. Bunlardan ilki ve en basiti, konsola <code>bash betik_dosyası_adı</code> şeklinde komut vermektir. </p><figure id="506c57f3-879a-40ff-895a-5b847c68f8da" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/9.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/9.png"/></a></figure><p id="5235cbc9-60df-45c9-9d70-f8e5bee6b80b" class="">Burada yapmış olduğumuz işlem, betik yazarken kullanmış olduğumuz kabuk dilini yani betiğin çalışabileceği ortamı doğrudan belirtmektir. </p><p id="3dc67d6d-0867-40bd-8e91-87a6b9737221" class="">Ayrıca betik dosyamızı <code>./betik</code> komutuyla da çalıştırabiliriz.</p><p id="5ef9cabd-0293-417d-b935-2eed756fb04a" class="">Aslında bu kullanım ilkine oranla daha sık tercih edilen bir yöntemdir. Hatta betik dosyalarını çalıştırmak için doğru olan temel kullanım yöntemimiz budur.</p><p id="1fd2ff60-1b4e-4ea4-a0d3-357a795a7d9e" class="">Ancak bu kullanımda diğer kullanımdan farklı olarak, dosyamızın çalıştırma yetkisinin bulunması gerekiyor. Aksi takdirde gördüğünüz gibi dosyamız <strong>erişim yetkisi hatası</strong>(&quot;<strong>Erişim engellendi</strong>&quot;) belirterek çalıştırılamıyor.</p><figure id="670ccb03-db50-44bb-a396-0b3e792fb34b" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/11.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/11.png"/></a></figure><p id="e723bede-b32b-4e9a-aed0-524505cb8a9f" class="">Hatta durumu teyit etmek üzere <code>ls -la</code> komutu ile dosyamızın yetkilerini inceleyecek olursak, dosyamızda çalıştırma yetkisinin bulunmadığını görebiliriz.</p><figure id="6adfa5f4-bd18-49df-a496-73a77ff6353f" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/12.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/12.png"/></a></figure><p id="6a905228-84f3-4ef1-b2c6-b158cabfd008" class="">Bu sorunu aşmak için dosyamıza <code>chmod</code> komutu ile gereken çalıştırma yetkisini vermemiz gerekiyor.</p><p id="df5fecbc-4db6-494d-8d9c-eb28f09c8bdf" class="">Ben tüm kullanıcılara çalıştırma yetkisi vermek için konsola <code>chmod +x selam.sh</code> komutunu giriyorum. İşlemin ardından <code>ls -la</code> komutu ile dosyamızın aldığı yetkiyi teyit edebiliriz.</p><figure id="9a4d8ea4-dd27-499d-b197-4b4174997efe" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/13.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/13.png"/></a></figure><p id="84dcda17-24b8-475d-95b0-b0f31e7aff15" class="">Çıktılardan da anlayabileceğimiz gibi dosyamız artık çalıştırılabilir durumda. Hemen dosyamızı çalıştırarak bu durumu kesin olarak teyit edelim.</p><figure id="2f8540ad-e2af-4863-a6e0-cb567f428b9b" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/14.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/14.png"/></a></figure><p id="7a46dad2-6da1-463a-a746-6cac0dad522e" class="">Ve gördüğünüz gibi betik dosyamız aldığı yetki sayesinde sorunsuz şekilde çalışmış oldu. Eğer yetkilendirme işlemini ve işlemde kullanılan komut bütününü anlamadıysanız temel Linux bilginizi tazelemeniz gerekebilir. Zira benim özellikle ayrıntılı olarak anlatmadığım tüm konular temel Linux bilgisi kapsamındaki konulardır. Lütfen eğitimden maksimum verimi alabilmek adına temel Linux bilginiz olduğundan emin olarak eğitime devam edin.</p><p id="7c48b7e7-3791-4506-8f35-78a6d5ed8115" class="">Dosyamızı çalıştırdık ancak, dosyamızı çalıştırmak üzere girmiş olduğumuz komutun çalışma yapısını daha iyi anlamak adına, kullanmış olduğumuz <code>./</code> ifadesini de ayrıca açıklamak istiyorum.</p><p id="ad184ba9-5b20-4063-8c2f-d3e212b7c054" class="">Komutumuzda kullandığımız <code>.</code>(nokta) ifadesi, şu anda bulunmakta olduğumuz mevcut dizini temsil ediyor.</p><p id="caa881c8-db00-4297-812a-b34ed2ff51a5" class="">Noktadan sonra kullanmış olduğumuz <code>/</code>(slash-taksim) ifadesi ise bulunduğumuz konumdaki betik dosyasına ulaşıp çalıştırmamızı sağlıyor.</p><p id="560433b0-f570-4f7d-b1ea-90bd5c50729d" class="">Yani benim konsola <code>./selamlar.sh</code> şeklinde yazmamla <code>/root/selam.sh</code> şeklinde yazmam aslında aynı şeyi ifade ediyor. Bu örnekte bulunduğum mevcut konum <strong>/root</strong> dizini olduğu için <strong>nokta</strong> ifadesi bu konumu temsil ediyor. Kabuğa taksim işareti <code>/</code> ile bir dosyanın tam konumu belirtildiğinde, kabuk bu dosyanın uygun ortamda çalıştırılmasını sağlar. Yani kabuğa taksim işareti ile tam konumu belirtilmiş olan tüm dosyalar kabuğun gözünde &quot;çalıştırılacak dosya&quot; sınıfındadır.</p><figure id="27f1dd61-4db4-4fe0-8865-51a9aedb505e" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/15.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/15.png"/></a></figure><p id="4d158948-50a9-4cfe-999a-151aebe421c9" class="">Şu ana kadar her şey harika gitti ve betik dosyamızı iki farklı yoldan nasıl çalıştırabileceğimizi görmüş olduk.</p><p id="06651f2f-dba3-4185-8bd2-03993458d1c2" class="">Peki ama daha öncesinde <code>bash</code> komutu ile aynı dosyamızı çalıştırma yetkisi bulunmamasına rağmen nasıl çalıştırabilmiştik ?</p><p id="607cd3cb-7239-4ff4-8dd5-2e11c4549062" class="">Yani <code>bash selamlar.sh</code> ile <code>./selamlar.sh</code> kullanımları arasındaki yetki almayı gerektiren fark neydi ?</p><p id="d59a5216-0bac-45f8-a947-eab9cfdf24ef" class="">Bu durumun nedeni <code>bash</code> komutunu kullandığımızda konsola, &quot;<em><strong>bu bir bash kabuk betiğidir, bu betiği doğrudan bash ortamında çalıştırabilirsin</strong></em>&quot; diyor olmamızdır. Halihazırda bash kabuğunu çalıştırma yetkimiz olduğundan(nitekim şu an ona emir veriyoruz), bu dosya için ekstra çalıştırma yetkisine ihtiyaç duymadan bash üzerinden çalıştırabildik. Kabuğa bash <a href="http://selamlar.sh">selamlar.sh</a> komutu girdiğimde; mevcut kabuğum bash aracını çalıştırmak istediğimi çekirdeğe bildiriyor, çekirdekte çalıştırma yetkim olduğu için bash aracını &quot;selamlar.sh&quot; argümanı ile çalıştırmama izin veriyor. Argüman olarak &quot;selamlar.sh&quot; dosyasını alan bash aracı en nihayetinde betiği alıp işliyor.</p><p id="7b0a29cc-26d7-43fc-9cb3-c165150f1341" class="">Öte yandan kabuğa <code>./betik</code> şeklinde emir verdiğimizde, &quot;<em>al bu dosyayı uygun ortam hangisi ise onda çalıştır</em>&quot; demiş oluyoruz. Kabukta; &quot;<em>madem dosyanın çalıştırılmasını istiyorsun o zaman dosyanın çalıştırılabilirlik durumuna bakayım ona göre çalıştırılmasını sağlayayım</em>&quot; diyor. Eğer dosyanın çalıştırılma yetkisi yoksa dosya içeriği henüz okunmadan &quot;erişim engellendi&quot; hatası ile işlemi iptal ediyor. Dosyanın çalıştırılabilirlik yetkisi varsa hangi ortamda çalıştırılacağını öğrenmek için dosyanın ilk satırını okuyor. Eğer bizler ilk satırı boş bırakmışsak yani &quot;shebang&quot; tanımını eklemediysek konsol sistemde varsayılan olarak kullanılan kabuk dili aracılığı ile dosyamızı çalıştırmayı deniyor. Şayet ilk satırda başka bir kabuk dili veya çalışma ortamı belirtmişsek de bu ortamda dosyanın çalıştırılmasını sağlıyor. Hatta bu durumu teyit etmek üzere, dosyamızın başına alakasız bir çalışma ortamı belirterek deneyelim.</p><p id="b172e6e9-e3c2-4615-a831-d4e80a1fba83" class="">Dosyamın başına <strong>/bin/bash</strong> yerine <strong>/bin/deneme</strong> şeklinde bir ifade ekleyip kaydediyorum.</p><figure id="95ac3ef6-ac99-4f00-a318-a964c9d3c490" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/16.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/16.png"/></a></figure><p id="7044af82-957f-4944-ad12-f877ff30b460" class="">Ve dosyamı <code>./selamlar.sh</code> şeklinde çalıştırmayı deniyorum.</p><figure id="f9b1d8c5-2cdb-4a17-8485-eb3b0a91758b" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/17.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/17.png"/></a></figure><p id="300019ad-6842-4676-8fda-53b79665cc72" class="">Bu işlemin sonucunda konsol bana &quot;<em><strong>hatalı yorumlayıcı: Böyle bir dosya ya da dizin yok</strong></em>&quot; şeklinde çıktı basarak, shebang kısmında belirtilen ortamın mevcut olmadığını belirtmiş oluyor.</p><p id="cdcba5c7-2e00-4a84-acaa-e36702c25b55" class="">Aynı dosyayı <code>bash selamlar.sh</code> komutu ile çalıştırdığımda ise, sistem dosyanın shebang kısmında yer alan ortamın ne olduğuna bakmadan doğrudan bash ortamında dosyayı çalıştırıyor.</p><figure id="20497b55-bde0-4018-a531-fcad069a9854" class="image"><a href="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/18.png"><img src="https://raw.githubusercontent.com/taylanbildik/bash_script_dersleri/master/img/Ba%C5%9Flarken/18.png"/></a></figure><p id="8bace8d8-cba1-43ca-92d2-ab7a7a5a0e37" class="">En nihayetinde ilk betik dosyamızı oluşturup sorunsuzca çalıştırmayı başardık. Üstelik anlatım sırasında hangi işlemin neden gerçekleştiğini de sırasıyla öğrenmiş olduk.</p><p id="36ae8e45-711b-40f9-8e7e-1b832741c207" class="">Bir sonraki kısımda kısaca kabuğun komutları nasıl ele aldığından bahsedip, değişkenlere de değiniyor olacağız.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="fad0c6c0-b2e3-4dce-857e-6eae07f27509"><div style="font-size:1.5em"><span class="icon">ℹ️</span></div><div style="width:100%"><mark class="highlight-blue"><strong>Ek Açıklama:</strong></mark> Anlatımlar sırasında tıpkı bu bölümde olduğu gibi kullanacağımız yapıları ve bu yapıların tepkilerini anında gözlemeyebilmek için öncelikle konsol üzerinden etkileşimli şekilde ele alıyor olacağız. Zaten anlatımlara devam ettikçe öğrendiğimiz yapıları nasıl betik dosyası içerisinde bir bütün halinde kullanabileceğimizi de öğrenmiş olacağız. Özetle bu eğitim her ne kadar betik oluşturmak üzerine olsa da öğrenme aşamasında genellikle doğrudan sonuçları görebileceğimiz etkileşimli kabuk yani konsol üzerinden ilerliyor olacağız.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="ffaf06d4-0a35-420c-97b3-6098cd6c602a"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%"><mark class="highlight-yellow"><strong>Yazar Notu:</strong></mark> Anlatımlar sonuç odaklı bir yol izlemekten ziyade temeli sağlam oluşturmak üzere ilerlediğinden kimi kısımlardaki anlatımlar belki biraz uzun olarak gözükebilir. Ancak eğitim sürecinde yer alan anlatımların, konuyu iyi bir biçimde kavramanız ve kolay öğrenmeniz için bulunduğunu lütfen unutmayın. Yani tüm gayretimiz &quot;ne&quot; olduğundan ziyade &quot;neden&quot; olduğunu kavrayabilmektir. Bu sayede öğrendiğimiz bilgiler bizim için gerçekten anlamlı ve kalıcı olabilir. Ve çok daha önemlisi merak duygunuzu tetikleyerek daha derinlemesine araştırma yapmanızı sağlayabilir. Eğitmen olarak bana inanmıyorsanız bile sadece güvenin ve eğitim sonunda kararınızı kendiniz verin. Özetle anlatımı yapılan hiç bir konuyu ben özellikle belirtmediğim sürece doğrudan geçmenizi tavsiye etmem.(Ara vermek ya da sıkılıp daha sonrası için bırakmayı kast etmiyorum. Bir daha okumamak üzere doğrudan atlamaktan bahsediyorum.)</div></figure><p id="0869f2b2-bcb2-4eec-8dc8-77287de59807" class="">Betik dosyamızı oluşturup nasıl çalıştırabileceğimizi öğrendik. Peki ama kabuk dediğimiz yapı bizden aldığı emirleri nasıl anlamlandırıp gerektiğinde ilgili aracı bulup çalıştırıyor ? Yani kabuk aslında nasıl çalışıyor ?</p><h1 id="084956ca-4b55-4cf8-9caf-00a853b86f2f" class="">Kabuk Nasıl Çalışır ?</h1><p id="f2ce33b1-84d6-4322-a033-83b85f7582c3" class="">Elbette tüm detayları ile kabuğun nasıl çalıştığına şimdilik değinmeyeceğiz. Burada  genel çalışma yapısından bahsedip kitap boyunca bu yapıya atıfta bulunarak ayrıntılarından uygulamalı olarak bahsediyor olacağız. Bu sayede kitabın sonlarına doğru tüm çalışma yapısını uygulamalı olarak teyit etmiş olacağız.</p><p id="735e7876-cabb-4dfb-a94b-d7e57e7d7e8f" class="">Kabuğun aslında bir yazılım olduğundan ve bize grafiksel arayüz harici bir çalışma ortamı sunduğunu biliyoruz. Kabuğa bir emir veririz kabukta bu emiri anlamlandırıp işlemin gerçekleştirilmesine aracılık eder. </p><p id="7fecca26-2147-45e7-957c-51fe5c5e1e27" class="">
</p><p id="cf544549-7f86-4a7f-9acb-47d40e56cff1" class="">
</p></div></article></body></html>